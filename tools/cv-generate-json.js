// Generated by LiveScript 1.3.1
(function(){
  var _, moment, fs, color, optimist, patt, print, pad, months, fix_month, strip, fix_identifier, format_name, fix_names, getauthors, getdate, print_id, print_conference, print_book, print_journal, print_patent, argv, print_what, print_stats;
  _ = require('underscore');
  _.str = require('underscore.string');
  moment = require('moment');
  fs = require('fs');
  color = require('ansi-color').set;
  optimist = require('optimist');
  _.mixin(_.str.exports());
  _.str.include('Underscore.string', 'string');
  patt = {
    "zaccaria": "Vittorio      Zaccaria",
    "palermo": "Gianluca      Palermo",
    "silvano": "Cristina      Silvano",
    "sami": "Mariagiovanna Sami",
    "sciuto": "Donatella     Sciuto",
    "fornaciari": "William       Fornaciari",
    "piuri": "Vincenzo      Piuri",
    "zafalon": "Roberto       Zafalon",
    "bona": "Andrea        Bona",
    "prestileo": "Andrea        Prestileo",
    "benini": "Luca          Benini",
    "mariani": "Giovanni      Mariani",
    "salvemini": "Lorenzo       Salvemini",
    "bertels": "Koen          Bertels",
    "sima": "Vlad          Mihai Sima",
    "bertoni": "Guido         Bertoni",
    "bircan": "Aril          Bircan",
    "breveglieri": "Luca          Breveglieri",
    "fragneto": "Pasqualina    Fragneto",
    "macchetti": "Marco         Macchetti",
    "valsecchi": "Simone        Valsecchi",
    "monchier": "Matteo        Monchiero",
    "chinosi": "Mauro         Chinosi",
    "Bruni": "Davide        Bruni",
    "pagni": "Andrea        Pagni",
    "lucini": "Fabrizio      Lucini",
    "pau": "Danilo Pietro Pau",
    "borneo": "Antonio       Borneo",
    "soti": "Sotiris       Xydis",
    "aone": "Edoardo       Paone",
    "reghiz": "Stefano Crespi Reghizzi",
    "elpign": "Diego         Melpignano",
    "ossei": "Amir          Ashouri",
    "iacomo": "Giacomo Marchiri",
    "augou": "Germain Haugou",
    "epley": "Thierry Lepley",
    "ellasi": "Patrick Bellasi",
    "assari": "Giuseppe Massari",
    "adioli": "Davide Gadioli",
    "gosta": "Giovanni Agosta",
    "andale": "Michele Scandale",
    "ibutti": "Simone Libutti"
  };
  print = console.log;
  pad = 25;
  months = {
    "jan": "January",
    "feb": "February",
    "mar": "March",
    "apr": "April",
    "may": "May",
    "jun": "June",
    "jul": "July",
    "aug": "August",
    "sep": "September",
    "oct": "October",
    "nov": "November",
    "dec": "December"
  };
  fix_month = function(r){
    var short, ref$, long, results$ = [];
    if (r.month != null) {
      for (short in ref$ = months) {
        long = ref$[short];
        if (_.str.include(r.month.toLowerCase(), short)) {
          results$.push(r.month = long);
        }
      }
      return results$;
    }
  };
  strip = function(s){
    return _.words(s)[1];
  };
  fix_identifier = function(r){
    if (r.identifier != null) {
      return r.identifier.map(function(m){
        if (_.str.include(m.id.toLowerCase(), "issn")) {
          m.type = "issn";
        }
        if (_.str.include(m.id.toLowerCase(), "isbn")) {
          m.type = "isbn";
        }
        if (_.str.include(m.id.toLowerCase(), "issn") || _.str.include(m.id.toLowerCase(), "isbn")) {
          return m.id = strip(m.id);
        }
      });
    }
  };
  format_name = function(n){
    var cn;
    cn = _.words(n);
    cn[0] = cn[0][0] + ". ";
    return _.clean(_.toSentence(cn, ' ', ' '));
  };
  fix_names = function(r){
    return r.author.forEach(function(a){
      var cn, nn, short, ref$, long;
      cn = _.words(a.name, ",");
      if (cn[1] != null) {
        nn = _.clean(cn[1] + ". " + cn[0]);
      } else {
        nn = a.name;
      }
      a.name = nn;
      for (short in ref$ = patt) {
        long = ref$[short];
        if (_.str.include(a.name.toLowerCase(), short.toLowerCase())) {
          a.name = format_name(long);
        }
      }
      return ref$ = a.id, delete a.id, ref$;
    });
  };
  getauthors = function(d){
    return _.toSentence(d.author.map(function(m){
      return m.name;
    }));
    return names[0] + " *et al.*";
  };
  getdate = function(d){
    var td;
    td = [];
    if (d.year != null) {
      td = d.year;
      if (d.month != null) {
        if (d.day != null) {
          td = d.month + " " + d.day + ", " + td;
        } else {
          td = d.month + " " + td;
        }
      }
    }
    return td;
  };
  print_id = function(r){
    var ids, idd;
    if (r.identifier != null) {
      ids = r.identifier.map(function(i){
        if (i.type === "isbn") {
          return "[isbn](http://www.worldcat.org/isbn/" + i.id + ")";
        }
        if (i.type === "issn") {
          return "[issn](http://www.worldcat.org/issn/" + i.id + ")";
        }
        if (i.type === "doi") {
          return "[doi](http://dx.doi.org/" + i.id + ")";
        }
      });
      idd = " \\[ " + _.toSentence(ids, '|') + " \\]";
    } else {
      idd = "";
    }
    return idd;
  };
  print_conference = function(r){
    var pages, location, idd;
    pages = r.pages != null ? ", pp. " + r.pages : "";
    location = r.address != null ? r.address + "" : "";
    idd = print_id(r);
    if (!in$('accepted', r.keyword)) {
      return print("1. " + getauthors(r) + ", *" + r.title + "*, **" + r.booktitle + "**" + pages + " - " + location + " " + getdate(r) + ". " + idd);
    } else {
      return print("1. " + getauthors(r) + ", *" + r.title + "*, **" + r.booktitle + "**, **Accepted for publication** (awaiting production).");
    }
  };
  print_book = function(r){
    var pages, location, idd;
    pages = r.pages != null ? ", " + r.pages + " pages" : "";
    location = r.address != null ? r.address + "" : "";
    idd = print_id(r);
    return print("1. " + getauthors(r) + ", **" + r.title + "**" + pages + " - " + r.publisher + ", " + location + " " + getdate(r) + ". " + idd);
  };
  print_journal = function(r){
    var pages, location, idd;
    pages = r.pages != null ? ", pp. " + r.pages : "";
    location = r.address != null ? r.address + "" : "";
    idd = print_id(r);
    if (!in$('accepted', r.keyword)) {
      return print("1. " + getauthors(r) + ", *" + r.title + "*, **" + r.journal.name + "**" + pages + " -  " + r.publisher + ", " + location + " - " + getdate(r) + ". " + idd);
    } else {
      return print("1. " + getauthors(r) + ", *" + r.title + "*, **" + r.journal.name + "**, **Accepted for publication** (awaiting production). ");
    }
  };
  print_patent = function(r){
    var pt, pn;
    pt = in$('application', r.keyword) ? "(A1 - application)" : "granted";
    pn = r.address + " " + _.numberFormat(_.toNumber(r.number), 0);
    return print("1. " + getauthors(r) + ", *" + r.title + "* - " + r.year + " - number: **" + pn + "** - type: **" + pt + "** - \\[ [url](" + r.link[0].url + ") \\]");
  };
  argv = optimist.usage('Generate markdown from json csv files.\nUsage: $0 --option=V | -o V', {
    nohead: {
      alias: 'n',
      description: 'dont print header'
    },
    published: {
      alias: 'p',
      description: 'only published papers',
      'default': false
    }
  }).argv;
  print_what = function(data, what){
    return data.forEach(function(d){
      if (!argv.published || argv.published && !in$('accepted', d.keyword)) {
        if (in$(what, d.keyword)) {
          if (what === "conference") {
            print_conference(d);
          }
          if (what === "workshop") {
            print_conference(d);
          }
          if (what === "journal") {
            print_journal(d);
          }
          if (what === "patent") {
            print_patent(d);
          }
          if (what === "bookc") {
            print_conference(d);
          }
          if (what === "book") {
            return print_book(d);
          }
        }
      }
    });
  };
  print_stats = function(data){
    var s;
    s = _.countBy(data.records, function(r){
      if (in$("workshop", r.keyword)) {
        return "workshop";
      }
      if (in$("conference", r.keyword)) {
        if (_.str.include(r.booktitle.toLowerCase(), "date")) {
          return "date-conference";
        }
        if (_.str.include(r.booktitle.toLowerCase(), "dac")) {
          return "dac-conference";
        }
        return "conference";
      }
      if (in$("journal", r.keyword)) {
        if (_.str.include(r.journal.name.toLowerCase(), "transaction")) {
          return "transactions";
        }
        return "journal";
      }
      if (in$("book", r.keyword)) {
        return "book";
      }
      if (in$("bookc", r.keyword)) {
        return "book-chapter";
      }
      if (in$("patent", r.keyword)) {
        return "patent";
      }
    });
    print("| **Conferences**: " + (s['conference'] + s['date-conference'] + s['dac-conference']) + " | **Journals**: " + (s['transactions'] + s['journal']) + " |");
    print("|-----------------|--------------|");
    print("|    DATE:  " + s['date-conference'] + "          |    IEEE/ACM Transactions: " + s['transactions'] + " |");
    print("|    DAC/ASPDAC:  " + s['dac-conference'] + "     |    other: " + s['journal'] + "                      |");
    print("|    other: " + s['conference'] + "               |                                                |");
    print("| **Patents**: " + s['patent'] + "                | **Book Chapters**: " + s['book-chapter'] + "        |");
    return print("| **Workshops**: " + s['workshop'] + "            | **Books**: " + s['book'] + "                        |");
  };
  fs.readFile('/dev/stdin', 'utf8', function(err, data){
    var o_js, orig_js;
    if (err > 1) {
      return console.log("error");
    } else {
      o_js = JSON.parse(data);
      o_js.records.forEach(function(d){
        fix_names(d);
        fix_identifier(d);
        return fix_month(d);
      });
      orig_js = _.sortBy(o_js.records, function(d){
        return -1 * _.toNumber(d.year);
      });
      return console.log(JSON.stringify(orig_js, null, 4));
    }
  });
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
}).call(this);
